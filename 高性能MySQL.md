# 第 1 章 MySQL 架构与历史

## 1.1 MySQL 逻辑架构

* 第一层：客户端
* 第二层：服务器，包含大多数 MySQL 核心服务功能，如连接/线程处理、查询缓存、解析器、优化器以及所有内置函数，所有跨存储引擎功能（存储过程、触发器、视图）等
* 第三层：存储引擎，负责数据的存储和提取；服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎间的差异；存储引擎 API 包含几十个底层函数，用于执行诸如“开始事务”、“根据主键提取一行记录”等操作，但存储引擎不会解析 SQL（InnoDB 会解析外键定义，因为 MySQL 服务器本身没有此功能），不同引擎不会通信，只是响应上层服务器的请求

### 连接管理与安全性

每个连接会在服务器进程中拥有一个线程，服务器负责缓存线程（线程池），用少量线程服务大量连接。  
客户端连接时，需要进行认证，基于**用户名、原始主机信息和密码**，若使用了安全套接字（SSL），还可用 X.509 证书认证；连接成功后，验证该用户是否具有执行某个特定查询的权限

### 优化与执行

对于 SELECT 语句，服务器会先检查查询缓存，若有则返回缓存的结果集，没有才执行下面的操作；  
服务器会解析查询，并创建内部数据结构（解析树），然后对其进行优化，包括重写查询、决定表的读取顺序、选择合适索引等；用户可通过特殊关键字提示(hint)优化器，影响其决策过程；  
优化器不关心表使用什么存储引擎，但引擎对于优化是有影响的，优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等

## 1.2 并发控制

### 读写锁

为了使大量并发操作时，写操作不会互相干扰，读操作不会读到错误数据，需要一个由两种类型的锁组成的锁系统来解决问题；  
这两类锁为**共享锁和排它锁**，也叫**读锁和写锁**：读锁共享，同一时刻可以有多个读操作；写锁排它，会阻塞其它所有锁，在写操作时不能进行其它写操作和读操作

### 锁粒度

锁粒度越小则并发性越高，但对锁的管理也越消耗系统资源；  
锁策略就是在锁的开销和数据的安全性之间寻求平衡，MySQL 提供了多种选择，每种存储引擎都可以实现自己的锁策略和锁粒度

#### 表锁

MySQL 中最基本的锁策略，开销最小，会锁定整张表；写锁优先级比读锁高，一个写锁请求可能被插入到读锁队列的前面；  
存储引擎管理自己的锁，但服务器还会使用各种表锁来实现不同目的，比如服务器会为 ALTER TABLE 之类的语句使用表锁，忽略存储引擎的锁策略

#### 行锁

最大程度支持并发，最大锁开销；只在存储引擎层实现（InnoDB 等），服务器层完全不了解存储引擎中的锁实现

## 1.3 事务

ACID：原子性 atomicity、一致性 consistency、隔离性 isolation、持久性 durability

事务也会增加系统开销，可根据业务是否需要事务处理来选择合适的存储引擎，以获得更高性能

### 隔离级别

设置隔离级别： `SET [SESSION] TRANSACTION ISOLATION LEVEL SERIALIZABLE;`  

| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------- | ---- | ---------- | ---- | ------ |
| READ UNCOMMITTED | Y    | Y          | Y    | N      |
| READ COMMITTED   | N    | Y          | Y    | N      |
| REPEATABLE READ  | N    | N          | Y    | N      |
| SERIALIZABLE     | N    | N          | N    | Y      |

#### READ UNCOMMITTED 读未提交

事务中可读取到其它事务已修改但未提交的数据，即导致**脏读**；  
性能并没有好多少，会导致很多问题，一般很少使用

#### READ COMMITTED 读提交

大多数数据库的默认隔离级别，事务中只会读取到其它事务已提交的更改；  
但会导致**不可重复读**：事务中进行一次查询后，其它事务提交了更改，再次进行相同查询会得到不同结果

#### REPEATABLE READ 可重复读

MySQL 的默认隔离级别；  
保证了一个事务中多次读取同样记录的结果是一致的；  
但仍会导致**幻读**：在一个事务中读取某个范围内的记录，其它事务在该范围内插入新的记录，当再次读取该范围时，多出了新的记录（幻行）；InnoDB 和 XtraDB 存储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control)解决了幻读的问题

#### SERIALIZABLE 可串行化

最高隔离级别，强制事务串行执行，避免了幻读问题；  
会在读取的每一行数据上加锁，可能导致大量的超时和锁争用问题，除非很需要确保数据一致性且不需要并发时，才考虑使用

### 死锁

数据库系统实现了各种死锁检测和死锁超时机制来解决死锁。越复杂的系统，如 InnoDB，越能检测到死锁的循环依赖，并立即返回一个错误；另一种方法是当查询时间达到锁等待超时时放弃锁请求，但这不太好；  
InnoDB 目前的方法是，将持有最少行级排他锁的事务回滚；  
死锁发生后，只有部分或完全回滚其中一个事务才能打破，应用程序设计时必须考虑处理死锁，一般是重新执行因死锁回滚的事务

### 事务日志

帮助提高事务效率，存储引擎在修改表数据时只需要修改其内存拷贝，再把该修改行为记录到持久化在硬盘上的事务日志中，之后在后台慢慢将内存中被修改的数据持久化到硬盘中，称为**预写式日志**，修改数据需要写两次磁盘；  
事务日志采用追加的方式，写日志的操作是在磁盘上一小块区域内的顺序 I/O，相对随机 I/O 在磁盘多个区域移动磁头，效率更高；  
如果数据修改已记录到事务日志并持久化，但数据未写入磁盘，此时系统崩溃，存储引擎将在重启时自动恢复这部分修改的数据

### MySQL 中的事务

MySQL 提供了两种事务型存储引擎：InnoDB 和 NDB Cluster；此外还有一些第三方存储引擎也支持事务

#### 自动提交 AUTOCOMMIT

MySQL 使用 AUTOCOMMIT 变量来控制是否自动提交，默认为 ON(1)；  
启用时，除非显示开启事务，否则所有查询当做单独的事务直接提交；禁用时，当前会话的所有查询位于同一个事务中，直到提交或回滚，然后自动开启新事务；  
修改AUTOCOMMIT对非事务型的表没有影响，比如 MyISAM 或内存表，这些表由于没有事务概念，相当于一直处于自动提交模式；  
一些命令，如数据定义语言(DDL)的命令，在执行前会强制提交当前事务（如 ALTER TABLE,LOCK TABLES 等）

#### 在事务中混合使用存储引擎

服务器层不管理事务，事务由存储引擎管理，所以同一个事务混合使用存储引擎是不可靠的；  
如果混合使用了事务型和非事务型的表，正常提交时不会有问题；但需要回滚时，非事务型的表无法回滚，导致一致性被破坏，且很难修复；  
在非事务型的表上执行事务操作时，MySQL 不会发出提醒，只有回滚时才会发起警告  

#### 隐式和显示锁定

InnoDB 采用**两阶段锁定协议**，事务中，随时可执行锁定，锁只在事务结束时（提交或回滚）才会一起释放；根据隔离级别自动加锁是**隐式锁定**；  
支持通过特定语句**显示锁定**，这些语句不属于 SQL 规范，少用：
```SQL
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
```
MySQL 也支持 LOCK TABLES 和 UNLOCK TABLES 语句，这是服务器层实现的，和存储引擎无关，且不能代替事务处理，不如 InnoDB 的行级锁，会影响性能；  
* LOCK TABLES 与事务之间相互影响会变得很复杂，建议**只**在处于事务中并禁止自动提交时，可以用一下

## 1.4 多版本并发控制

大多事务型存储引擎基于提升并发性能的考虑，不只实现行级锁，还有多版本并发控制(MVCC)，类似行级锁的一个变种，在很多情况下避免加锁操作，开销更低；MCVV 大多实现非阻塞的多操作，写操作也只锁定必要行；  
MVCC 通过保存数据在某个时间点的快照来决定，不管执行多久，同个事务看到的数据是一致的，只会看到该事务开始时刻就存在的数据；  

MVVC 的实现一般有**乐观和悲观**并发控制；InnoDB 是通过在每行记录后保存两个隐藏列来实现的：都是系统版本号，一列是行创建时的，一列是行过期或删除时的，每开始一个新事务，版本号自动递增，事务开始时的版本号作为事务的版本号；  
在 REPEATABLE READ 隔离级别下，MVCC的 具体操作如下：
* SELECT：根据两个条件检查每行记录：
  * 只查找版本小于或等于当前事务版本的行
  * 行的删除版本未定义或大于当前事务版本
* INSERT：为新插入的每一行保存当前事务版本号
* DELETE：为删除的每一行保存当前事务版本号
* UPDATE：插入一行新记录，为其保存当前事务版本号，同时保存当前事务版本号到原来的行作为行删除标识

InnoDB 的 MVCC 使大多数读操作不用加锁，使读操作很简单，性能很好，也保证只会读到符合标准的行；缺点是每行记录需要额外的存储空间，需要做更多行检查工作和一些额外的维护工作；  
MVCC 只在 REPEATABLE READ 和 READ COMMITED 隔离级别下工作，因为 READ UNCOMMITED 总是读取最新数据行，而 SERIALIZABLE 则对所有读取行加锁  

## 1.5 存储引擎

在文件系统中，MySQL 将每个数据库(schema)保存为数据目录下的一个子目录，创建表时，在数据库子目录下创建一个和表同名的 .frm 文件保存表的定义；因为 MySQL 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感与平台有关（Windows 中大小写不敏感，类 Unix 中大小写敏感）；不同的存储引擎保存数据和索引的方式不同，但表的定义是服务器层统一处理的；  

### InnoDB

MySQL 的默认事务型引擎，最重要，使用最广泛，被设计用来处理大量的短期事务（大部分情况正常提交，很少被回滚）；InnoDB 的性能和自动崩溃恢复特性，使它在非事务型存储的需求中也很流行；  

InnoDB 的数据存储在表空间中，每个表的数据和索引可以存放在单独的文件中；存储格式是平台独立的，数据和索引文件可以在任意平台间使用；    
采用 MVCC 来支持高并发，实现四个标准的隔离级别（默认是可重复读），并通过间隙锁（next-key locking）防止幻读，间隙锁使 InnoDB 不仅锁定查询涉及的行，还对索引中的间隙进行锁定，防止幻影行插入；
* TIP：查阅网上资料，发现解决幻读问题，快照读（普通的 SELECT）使用的是 MVCC，读取对应版本的数据快照；当前读（UPDATE, DELETE, INSERT, SELECT …  LOCK IN SHARE MODE, SELECT … FOR UPDATE）读取当前实际数据，使用间隙锁

InnoDB 表基于聚簇索引建立，索引结构与其它存储引擎有很大不同；聚簇索引对主键查询有很高的性能，但其二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话，其它所有索引都会很大，若表上索引较多，主键应尽量小；  

InnoDB 通过一些机制和工具支持热备份（MySQL Enterprise Backup，XtraBackup），其它存储引擎都不支持，要获取一致性视图需要停止对所有表的写入  

### MyISAM

是 MySQL5.1 及之前版本的默认引擎，不支持事务和行级锁，崩溃后无法安全恢复；  
对于只读数据，或表比较小、可以忍受修复（repair）操作，仍可以使用 MyISAM；  

其它的看书吧，好像没什么记的必要

### 其它内建引擎
看书

### 第三方引擎
看书

### 选择合适引擎

InnoDB 首选，其它看书

### 转换表的引擎

三种方法

#### ALTER TABLE

`ALTER TABLE table_name ENGINE=InnoDB;`

需要执行很久，会按行将数据从原表复制到新表中，复制期间可能会消耗系统所有的 I/O 能力，同时原表会加读锁；  
转换引擎后，会失去和原引擎相关的所有特性；  

#### 导入导出

使用 mysqldump 工具将数据导出到文件，然后修改文件中 CREATE TABLE 语句的存储引擎选项，修改表名（同一库中的表不能重名），要注意 mysqldump 默认会自动在 CREATE TABLE 语句前加上 DROP TABLE 语句，不注意可能导致数据丢失

#### 创建与查询

兼具第一种的高效第二种的安全，先创建一个新存储引擎的表，再用 INSERT...SELECT 语句插入数据；若数据量大，要考虑分批处理

# 第 4 章 Schema 与数据类型优化

## 4.1 选择优化的数据类型

* 更小的通常更好
    一般应该尽量使用可以正确存储数据的最小数据类型，占用更少磁盘、内存和 CPU 缓存，处理时需要的 CPU 周期更少；  
    但是要确保没有低估存储的值的范围，因为在 schema 中多个地方增加数据类型的范围很耗时、麻烦
* 简单就好
    简单数据类型的操作通常 CPU 周期更少，整型就不字符串操作代价更低；比如用 MySQL 内建类型而不是字符串来存储日期时间，用整型存储 IP 地址
* 尽量避免 NULL
    除非真的需要存储 NULL 值，否则最好指定列为 NOT NULL。因为 NULL 的列使得索引、索引统计和值比较都更复杂，更难优化；可为 NULL 的列使用更多存储空间，需要特殊处理，当该列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至可能导致固定大小的索引变成可变大小的索引；不过将可为 NULL 的列改为 NOT NULL 带来的性能提升很小，不是很必要，但要在该列建索引的话，尽量为 NOT NULL；不过 InnoDB 用单独的位(bit)存储 NULL 值，对于稀疏数据（大多数为 NULL）有很好的空间效率

### 整数类型

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT (8, 16, 24, 32, 64 位)

整数类型都有可选的 UNSIGNED 属性，表示不允许负值，使用相同存储空间，性能不变，可使正数上限提高一倍；  
指定整数类型长度，如 INT(11)，只是规定一些交互工具（如命令行客户端）用来显示字符的个数，对于存储和计算没有意义

### 实数类型

FLOAT, DOUBLE, DECIMAL

FLOAT 和 DOUBLE 支持使用标准的浮点运行进行**近似**运算；  
DECIMAL 用于存储**精确**的小数，支持**精确**计算(Version >= 5.0）；CPU 不支持对 DECIMAL 的直接计算，MySQL 服务器实现了 DECIMAL 的高精度计算，但慢于 CPU 原生浮点计算;  
实数类型可以指定精度；DECIMAL 可以指定小数点前后允许的最大位数，会影响列占用的空间，5.0 及以上版本将数字打包保存到一个二进制字符串中（每 4 个字节存 9 个数字），最多允许 65 个数字（早期版本为 254 个，且保存在未压缩的字符串，每个数字一个字节）；
浮点列指定精度会使 MySQL 悄悄选择不同的数据类型或存储是对值进行取舍，这些精度定义是非标准的，不推荐指定精度； 
浮点类型存储同样范围的值，比 DECIMAL 使用更少的空间，FLOAT 用 4 个字节，DOUBLE 用 8 个字节；MySQL 使用 DOUBLE 作为内部浮点计算的类型；
DECIMAL 开销较大，只有需要精确计算小数时才用，也可用 BIGINT 代替，将小数乘以响应倍数转换成整数

### 字符串类型

每个字符串列可以定义自己的字符集和排序规则，很大程度上影响性能；字符串长度定义的是字符数，而不是字节数；数据如何存储取决于存储引擎，但填充和截取空格是在服务器层处理的  

#### VARCHAR

可变长字符串，比定长类型更节省空间，仅使用必要的空间，但如果表使用 `ROW_FORMAT=FIXED` 创建的话，每行都会使用定长存储；  
需要使用 1 或 2 个额外字节记录字符串的长度：列最大长度小于或等于 255 字节用 1 个字节表示，否则用两个字节；  
由于行是变长的，在更新时可能使行变得比原来长，会导致需要做额外的工作：当增长后页内没有空间可以存储时，MyISAM 会将行拆成不同的片段存储，InnoDB 则需要分裂页来使行可以放进页内；  
适合用 VARCHAR 的情况：字符串列的最大长度比平均长度大很多；列的更新很少，碎片不是问题；使用像 UTF-8 这样的复杂字符集，每个字符字节数不一定相同；  
在 5.0 及以上版本，VARCHAR 存储和检索时保留末尾空格；  
InnoDB 比较灵活，可以把过长的 VARCHAR 存储为 BLOB；  
尽量只使用刚好够用的长度，因为在内存中会分配固定大小的内存块来保存内部值，设定长度越大内存消耗越大，在使用内存临时表进行操作或排序时会很糟糕，利用磁盘临时表排序也一样糟糕    

#### CHAR

定长字符串，存储时删除所有末尾空格，会根据需要用空格填充以方便比较；  
适合存储很短的字符串，或者所有值都接近同一个长度，对于经常变更的数据，也比 VARCHAR 好，不容易产生碎片；对于很短的列，也比 VARCHAR 在空间上更有效率，因为 VARCHAR 需要多用一个字节记录长度；  
类似的类型有 BINARY 和 VARBINARY，存储二进制字符串，但存储的是字节码不是字符，填充 BINARY 用 \0（零字节）而不是空格，检索时不会去掉填充值；二进制比较按字节比较，更简单更快

#### BLOB 和 TEXT

用于存储庞大数据，分别采用二进制(BLOB)和字符(TEXT)方式存储；  
BLOB: TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB；(SMALLBLOB=BLOB)  
TEXT: TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT；(SMALLTEXT=TEXT)  