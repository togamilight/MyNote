# 第 1 章 MySQL 架构与历史

## 1.1 MySQL 逻辑架构

* 第一层：客户端
* 第二层：服务器，包含大多数 MySQL 核心服务功能，如连接/线程处理、查询缓存、解析器、优化器以及所有内置函数，所有跨存储引擎功能（存储过程、触发器、视图）等
* 第三层：存储引擎，负责数据的存储和提取；服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎间的差异；存储引擎 API 包含几十个底层函数，用于执行诸如“开始事务”、“根据主键提取一行记录”等操作，但存储引擎不会解析 SQL（InnoDB 会解析外键定义，因为 MySQL 服务器本身没有此功能），不同引擎不会通信，只是响应上层服务器的请求

### 连接管理与安全性

每个连接会在服务器进程中拥有一个线程，服务器负责缓存线程（线程池），用少量线程服务大量连接。  
客户端连接时，需要进行认证，基于**用户名、原始主机信息和密码**，若使用了安全套接字（SSL），还可用 X.509 证书认证；连接成功后，验证该用户是否具有执行某个特定查询的权限

### 优化与执行

对于 SELECT 语句，服务器会先检查查询缓存，若有则返回缓存的结果集，没有才执行下面的操作；  
服务器会解析查询，并创建内部数据结构（解析树），然后对其进行优化，包括重写查询、决定表的读取顺序、选择合适索引等；用户可通过特殊关键字提示(hint)优化器，影响其决策过程；  
优化器不关心表使用什么存储引擎，但引擎对于优化是有影响的，优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等

## 1.2 并发控制

### 读写锁

为了使大量并发操作时，写操作不会互相干扰，读操作不会读到错误数据，需要一个由两种类型的锁组成的锁系统来解决问题；  
这两类锁为**共享锁和排它锁**，也叫**读锁和写锁**：读锁共享，同一时刻可以有多个读操作；写锁排它，会阻塞其它所有锁，在写操作时不能进行其它写操作和读操作

### 锁粒度

锁粒度越小则并发性越高，但对锁的管理也越消耗系统资源；  
锁策略就是在锁的开销和数据的安全性之间寻求平衡，MySQL 提供了多种选择，每种存储引擎都可以实现自己的锁策略和锁粒度

#### 表锁

MySQL 中最基本的锁策略，开销最小，会锁定整张表；写锁优先级比读锁高，一个写锁请求可能被插入到读锁队列的前面；  
存储引擎管理自己的锁，但服务器还会使用各种表锁来实现不同目的，比如服务器会为 ALTER TABLE 之类的语句使用表锁，忽略存储引擎的锁策略

#### 行锁

最大程度支持并发，最大锁开销；只在存储引擎层实现（InnoDB 等），服务器层完全不了解存储引擎中的锁实现

## 1.3 事务

ACID：原子性 atomicity、一致性 consistency、隔离性 isolation、持久性 durability

事务也会增加系统开销，可根据业务是否需要事务处理来选择合适的存储引擎，以获得更高性能

### 隔离级别

| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------- | ---- | ---------- | ---- | ------ |
| READ UNCOMMITTED | Y    | Y          | Y    | N      |
| READ COMMITTED   | N    | Y          | Y    | N      |
| REPEATABLE READ  | N    | N          | Y    | N      |
| SERIALIZABLE     | N    | N          | N    | Y      |

#### READ UNCOMMITTED 读未提交

事务中可读取到其它事务已修改但未提交的数据，即导致**脏读**；  
性能并没有好多少，会导致很多问题，一般很少使用

#### READ COMMITTED 读提交

大多数数据库的默认隔离级别，事务中只会读取到其它事务已提交的更改；  
但会导致**不可重复读**：事务中进行一次查询后，其它事务提交了更改，再次进行相同查询会得到不同结果

#### REPEATABLE READ 可重复读

MySQL 的默认隔离级别；  
保证了一个事务中多次读取同样记录的结果是一致的；  
但仍会导致**幻读**：在一个事务中读取某个范围内的记录，其它事务在该范围内插入新的记录，当再次读取该范围时，多出了新的记录（幻行）；InnoDB 和 XtraDB 存储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control)解决了幻读的问题

#### SERIALIZABLE 可串行化

最高隔离级别，强制事务串行执行，避免了幻读问题；  
会在读取的每一行数据上加锁，可能导致大量的超时和锁争用问题，除非很需要确保数据一致性且不需要并发时，才考虑使用

### 死锁

数据库系统实现了各种死锁检测和死锁超时机制来解决死锁。越复杂的系统，如 InnoDB，越能检测到死锁的循环依赖，并立即返回一个错误；另一种方法是当查询时间达到锁等待超时时放弃锁请求，但这不太好；  
InnoDB 目前的方法是，将持有最少行级排他锁的事务回滚；  
死锁发生后，只有部分或完全回滚其中一个事务才能打破，应用程序设计时必须考虑处理死锁，一般是重新执行因死锁回滚的事务