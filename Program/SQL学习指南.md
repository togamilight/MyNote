# 第 2 章 创建和使用数据库

### 缺失的字句

某些数据库，比如 Oracle，规定查询语句中必须包含 from 字句，并至少指明一个表名。在 Oracle 中有一个特殊表 **dual**，只含有一个列 dummy，只有一个数据行，当查询语句不需要查表时，from 字句可以指向这个表。为了与 Oracle 兼容， MySQL 也有 dual 表

## 2.3 MySQL 数据类型

### 字符型

**定长**字符型 char，最大长度 255 字节；**变长**字符型 varchar，最大长度 65535 字节（Oracle 为 varchar2）

#### 字符集

拉丁系语言，每个字母只需要一个字节来存储，为**单字符集**；中日韩语等，每个字符需要多个字节来存储，为**多字符集**  

查看支持的字符集：  
`SHOW CHARACTER SET;`

### 文本

若数据超过 64KB(varchar 上限)，就需要文本类型  
| 类型       | 长度       |
| ---------- | ---------- |
| tinytext   | 255        |
| text       | 65535      |
| mediumtext | 16777215   |
| longtext   | 4294967295 |

* 如果数据超过该类型最大长度，数据会被截断
* 向文本列装载数据时，不会消除尾部空格
* 使用文本列排序或分组时，默认只会使用前 1024 个字节
* SQL Server 只有 text，DB2 和 Oracle 则是 clob(Character Large Object)
* 现在 varchar 最大 65535 字节，一般不需要使用 tinytext 和 text

### 数值型

整数(前面可加上 unsigned 表示无符号)：  
| 类型      | 带符号范围                               | 无符号范围             |
| --------- | ---------------------------------------- | ---------------------- |
| tinyint   | -128~127                                 | 0~255                  |
| smallint  | -32768~32767                             | 0~65535                |
| mediumint | -8388608~8388607                         | 0~16777215             |
| int       | -2147483648~2147483647                   | 0~4294967295           |
| bigint    | -9223372036854775808~9223372036854775807 | 0~18446744073709551615 |

浮点数：
| 类型        | 范围                                                                                                      |
| ----------- | --------------------------------------------------------------------------------------------------------- |
| float(p,s)  | -3.402823466E+38 ~ -1.175494351E-38<br/>1.175494351E-38 ~ 3.402823466E+38                                 |
| double(p,s) | -1.7976931348623157E+308 ~ -2.2250738585072014E-308<br/>2.2250738585072014E-308 ~ 1.7976931348623157E+308 |

浮点数可指定其精度：float(总位数, 小数位数)，但不是必须的，指定后，过长的小数位会被四舍五入；同样可以定义为 unsigned，但只是不能存放负数，不会扩大范围

### 时间

| 类型      | 默认格式            | 范围                                    |
| --------- | ------------------- | --------------------------------------- |
| date      | YYYY-MM-DD          | 1000-01-01~9999-12-31                   |
| datetime  | YYYY-MM-DD HH:MI:SS | 1000-01-01 00:00:00~9999-12-31 23:59:59 |
| timestamp | YYYY-MM-DD HH:MI:SS | 1970-01-01 00:00:00~2037-12-31 23:59:59 |
| year      | YYYY                | 1901~2155                               |
| time      | HHH:MI:SS           | -838:59:59~838:59:59                    |

## 2.4 表的创建

```sql
CREATE TABLE tablename( 
    colname TYPE, 
    ... ,
    CONSTRAINT pkname PRIMARY KEY (colname) -- 定义主键约束
);
```

还可以定义检查约束，限制字段能存储的值，如：
```sql
    gender CHAR(1) CHECK(gender IN('M', 'F'))

    -- 也可以使用 Mysql 的枚举类型达到类似效果
    gender ENUM('M', 'F')
```

# 第 6 章 使用集合

### 集合操作种类

* UNION/UNION ALL：并集，前者去重，后者不去重
* INTERSECT/INTERSECT ALL：交集，前者去重，后者不去重
* EXCEPT/EXCEPT ALL：差集，前者去重，后者不去重

### 集合操作规范

* 两个数据集必须具有同样数目的列
* 两个数据集对应列的数据类型必须一样（或者服务器能将其中一种转换为另一种）

# 第 9 章 子查询

## 子查询类型

子查询按结果集可分为：单行单列、单行多列、多行单列、多行多列等；  
* **单行单列**的为**标量子查询**，可用于常用运算符(=, <>, >, <, >=, <= 等)，还可以用在表达式可以出现的任何位置。  
* **多行单列**则可以用于 IN, NOT IN, ANY, ALL 运算符(ANY/ALL 前面需要有比较运算符)  
* **多列**子查询也可以用于 IN 运算符：`... WHERE (col1,col2) IN (SELECT col1,col2 FROM ...)`

子查询还可按**是否引用包含语句的列**分为**关联和非关联**子查询，关联子查询常与 EXISTS 运算符一起使用

# 第 12 章 事务

## 锁

大部分数据库采用以下两种锁策略：
* 写操作必须申请获得写锁，读操作必须申请获得读锁；多用户可同时读，但一个表（或其它部分）一次只能分配一个写锁，并拒绝读请求（SQL Server）
* 写操作必须申请获得写锁，读操作则不需要；但服务器要保证查询从开始到结束期间，读操作都面对一致的数据视图（即使其他用户修改，看到的数据也不变），这方法称为版本控制（Oracle）  
MySQL 视不同存储引擎使用不同的策略

### 锁的粒度

* 表锁
* 页锁：某表中同一页的数据（一页通常是一段 2~16 KB 的存储空间）
* 行锁（Oracle）

SQL Server 三种都有，MySQL 取决于存储引擎

## 事务

如果事务还未 commit 或 rollback，服务器突然宕机，那么事务会在服务器重启时被回滚（数据库服务器上线前必须完成的任务之一就是查找宕机前正在运行但未完成的事务，将其回滚）；如果事务 commit 了，但还没有将变化持久化到永久存储区（即修改的数据还在内存中，未写入硬盘），服务器宕机了，则服务器重启时数据库必须重新应用事务的变化

### 启动事务

一般有两种方式：
* 一个数据库会话对应一个活跃事务，不需要也无法显示启动事务；当前事务结束时，服务器自动为会话启动一个新事务（Oracle）
* 需要提交一个命令来显示启动事务，否则单个 SQL 语句独立于其他语句自动提交（SQL Server, MySQL）

SQL Server 和 MySQL 都可以为单个会话关闭自动提交模式，以第一种方式来使用事务，所有 SQL 语句发生在同一个事务中，事务必须显示提交或回滚：
* SQL Server: `SET IMPLICIT_TRANSACTIONS ON`
* MySQL: `SET AUTOCOMMIT=0`

### 结束事务

事务结束后，其使用的所有资源将被释放（即各种锁），以下几种情况将结束事务：
* commit/rollback
* 服务器宕机，重启时自动回滚事务
* 提交一个 SQL 模式语句，如 ALTER TABLE，将提交当前事务并启动新事务，且这个过程不会通知用户；因为数据库的更改是无法回滚的
* 显示启动一个新事务，将提交前一个事务
* 服务器检测到死锁并确定是当前事务导致的，将回滚该事务并释放错误信息

### 事务保存点

可以在事务内部创建一或多个保存点，利用它们来回滚到特定位置而不用回滚整个事务。

```sql
BEGIN

DECLARE EXIST HANDLER FOR SQLEXCEPTION 
ROLLBACK TO SAVEPOINT point1;   --回滚到保存点

START TRANSACTION;
UPDATE ...;
SAVEPOINT point1;   --保存点
UPDATE ...;
COMMIT;

END;
```

## MySQL 引擎与事务

Oracle 和 SQL Server 都有单独的一套代码负责低级别的数据库操作，但 MySQL 则是可以用多个存储引擎提供低级别的数据库功能，比如资源锁定和事务管理。  

MySQL 6.0 的存储引擎：
* MyISAM: 表级锁定非事务引擎
* MEMORY: 供内存表使用的非事务引擎
* BDB: 页级锁定事务引擎
* InnoDB: 行级锁定事务引擎
* Merge: 使多个相同 MyISAM 看起来像一个单表（也叫表分割）的专用引擎
* Maria: 6.0.6 版本中 MyISAM 的替代品，添加了充分的恢复功能
* Falcon: 行级锁定的高性能事务引擎
* Archive: 用于存储大量未索引数据的专用引擎，主要用来存档

对于参与事务的表，一般用 InnoDB 或 Falcon，采用**行级锁和版本控制**提供最高级别的并行能力

```SQL
--查看表
SHOW TABLE STATUS LIKE 'table_name';
--改变表的引擎
ALTER TABLE table_name ENGINE = INNODB;
```

# 第 13 章 索引和约束

## 索引

可以参考的索引策略：
* 确保所有主键被索引（大部分数据库会在创建主键约束是自动生成唯一索引）；对于多列主键，考虑为主键列的子集构建附加索引，或以与主机约束定义不同的顺序为所有主键列另外生成索引？
* 为所有被外键约束引用的列创建索引
* 索引那些被频繁检索的列，除了短字符串列（3~50个字符），大多数日期列也是不错的候选

## 约束

* 主键约束：标志一或多列，并保证其值在表内唯一
* 外键约束：限制一或多列的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值
* 唯一约束：限制一或多列的值，保证其在表里唯一
* 检查约束：限制一列的可用值范围

使用主键约束和唯一约束时，会自动生成唯一索引；使用外键约束时，MySQL 会生成soyn