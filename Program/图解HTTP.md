# 第一章 了解 Web 及网络基础

## 1.3 网络基础 TCP/IP

通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的，HTTP 是它的一个子集。

### TCP/IP 的分层管理

TCP/IP 协议族分为 4 层（从上到下）：
* **应用层**：决定了向用户提供应用服务时通信的活动；TCP/IP 协议族内预存了各类通用的应用服务，如 FTP（File Transfer Protocol，文件传输协议） 和 DNS（Domain Name System，域名系统） 服务。HTTP 属于这一层
* **传输层**：提供处于网络连接中的两台计算机之间的数据传输；传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议） 和 UDP（User Data Protocol，用户数据报协议）
* **网络层**：又名**网络互连层**，处理在网络上流动的数据包（数据包是网络传输最小单位），规定了通过怎样的传输路线到达对方计算机，并传送数据包，即在与对方机器间的众多计算机或网络设备中选择一条传输路线。IP（Internet Protocol，网际协议）属于这一层
* **链路层**：又名**数据链路层、网络接口层**，处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、网卡及光纤等物理可见部分（还包括连接器等一切传输媒介）

在 HTTP 协议中，原始的 HTTP 数据，每经过一层，就会附加上该层对应的**首部**，称为**封装**，到达接收端再一层一层拆开，还原成 HTTP 数据：
应用层生成 HTTP 数据 → 传输层附加 TCP 首部 → 网络层附加 IP 首部 → 链路层附加以太网首部

## 1.4 与 HTTP 关系密切的协议：IP、TCP 和 DNS

### 负责传输的 IP

IP（Internet Protocol，网际协议）位于**网络层**，负责把各种数据包传送给对方，需要 IP 地址 和 MAC 地址（Media Access Control Address）  
IP 地址是可变的，MAC 地址是网卡的固定地址，一般不变，它们之间可以进行配对，使用 ARP（Address Resolution Protocol，地址解析协议）根据 IP 地址反查 MAC 地址  
传输过程中，中转设备只能获悉很粗略的传输路线，通过 MAC 地址将数据传给下一个中转设备，这种机制称为**路由选择**

### 确保可靠性的 TCP

TCP 位于传输层，提供可靠的字节流服务  
* **字节流服务**：为方便传输，将大块数据**分割**成以报文段（Segment）为单位的数据包进行管理。  
* **可靠性**：数据包发送之后，TCP 会确认数据是否送达，通过**三次握手**策略，使用了 TCP 的标志 -- SYN(synchronize) 和 ACK(acknowledgement)
    * **三次握手**：
        1. 发送端先发送一个带 SYN 标志的数据包给对方
        2. 接收方收到后，回复一个带有 SYN/ACK 标志的数据包表示传达确认信息
        3. 发送端再回复一个带 ACK 标志的数据包，代表“握手”结束
        * 如果握手过程中某个阶段突然中断，TCP 会再次以相同顺序发送相同数据包
    * 除了三次握手，TCP 还有其它各种手段保证通信的可靠性

### 负责域名解析的 DNS 服务

DNS 服务位于应用层，提供域名到 IP 地址间的解析服务，从 DNS 服务器通过域名查找 IP 地址或从 IP 地址反查域名

## 1.7 URI 和 URL

URL(Uniform Resource Locator, 统一资源定位符) 是 URI(Uniform Resource Identifier, 统一资源标识符) 的一种形式，另一种形式是 URN(统一资源名)，不常用

### URI

* **Uniform**：统一的格式，方便处理多种不同类型的资源，加入新增的协议方案也方便(http/ftp)
* **Resource**：资源是指**可标识的任何东西**，可以是复数的集合体
* **Identifier**：标识符，表示可标识的对象

### 绝对 URI 格式

http://^1^user:pass^2^@www.example.com^3^:80^4^/dir/index.html^5^?uid=1^6^\#ch1^7^

1. **协议方案名**：获取访问资源时要指定协议类型，最后加一个冒号，也可使用 **data:** 或 **javascript:** 这类指定数据或脚本程序的方案名
2. **登录信息**：指定用户名和密码作为从服务器获取资源的身份认证，可选
3. **服务器地址**：可以是域名或者 ip，ipv6 用 **[ ]** 括起来
4. **服务器端口号**：指定服务器连接的网络端口，可选，默认为 80
5. **文件路径**
6. **查询字符串**：参数，可选
7. **片段标识符**：标记子资源，如文档内的某个位置，可选

# 第二章 简单的 HTTP 协议

## 2.2 通过请求和响应的交换达成通信

* 请求报文结构
  > GET /xx/x.html HTTP/1.1 （请求方法 URI 协议版本）
    Key: Value              （请求首部）
                            （空行）
    ...                     （内容实体）

* 响应报文结构
  > HTTP/1.1 200 OK （协议版本 状态码 状态码的原因短语）
    Key: Value      （响应首部）
                    （空行）
    ...             （主体）

## 2.3 HTTP 是不保存状态的协议

即**无状态**协议，HTTP 对于发送过的请求和响应都不做持久化处理,可以更快地处理大量事务，确保协议的伸缩性
但是无状态也很不方便，所以引入了 Cookie 这一功能来保存状态

## 2.4 请求 URI 定位资源

URI 可以定位互联网上任意位置的资源  
请求 URI 的方式：  
* 使用绝对 URI：`GET http://xxx.com/xxx.html HTTP/1.1`
* 使用相对 URI 并在首部字段 Host 中写明域名或 IP
    > GET /xxx.html HTTP/1.1
      Host：xxx.com
* 当不访问特定资源而对服务器本身发起请求时，使用 `*` 作为 URI，如查询服务器支持的 HTTP 方法种类
    `OPTIONS * HTTP/1.1`

## 2.5 告知服务器意图的 HTTP 方法
HTTP/1.1：
* GET：获取资源（REST 中用来获取）
* POST：传输实体主体（REST 中用来添加）
* PUT：传输文件，在报文主体中包含文件内容，保存到请求 URI 指定的位置，但是由于不带验证机制，任何人都可上传，一般不使用。（REST 中用来修改）
* DELETE：删除文件，与 PUT 一样，很少使用。（REST 中用来删除）
* HEAD：与 GET 一样，但不返回报文主体部分，用于确认 URI 的有效性和资源的更新时间等
* OPTIONS：询问该 URI 指定的资源支持的方法
* TRACE：追踪路径，让服务器将之前的请求通信环回给客户端。发送请求是，在首部字段 Max-Forwards 中填入数值，每经过一个服务器端就减 1，当数值刚好减到 0 时，停止继续传输，最后接收到请求的服务器端返回状态码 200 OK 的响应。客户端通过 TRACE 方法查询发送的请求是怎样被加工修改、篡改的，中间经过的代理中转。但是不常用，而且容易引发 XST(Cross-Site Tracing，跨站追踪)，基本不用。
* CONNECT：要求用隧道协议连接代理，即与代理服务器通信时建立隧道，用隧道协议进行 TCP 通信。主要使用 SSL(Secure Socket Layer，安全套接层) 和 TLS(Transport Layer Security，传输层安全) 协议把通信内容加密后经网络隧道传输。格式如下：
    `CONNECT 代理服务器名:端口号 HTTP版本`
代理服务器成功响应后，进入网络隧道

## 2.7 持久连接节省通信量

在 HTTP 1.0 中，每进行完一次 HTTP 通信就要断开 TCP 连接，造成了无谓的开销。

为解决这个问题，提出了**持久连接**的方法，只要任意一端没有提出断开连接，则保持 TCP 连接状态。如此，在建立 1 次 TCP 连接后，可进行多次请求和响应的交互，减少了开销。在 HTTP/1.1 中，所有连接默认都是持久连接  

持久连接使请求可以以**管线化**方式发送，即并行发送多个请求，而不用等待上一个请求获得响应

## 2.8 使用 Cookie 的状态管理

服务器通过发送的 **Response** 报文的 **Header** 中的 **Set-Cookie** 字段通知客户端保存 **Cookie**，客户端每次请求时，会自动在 **Header** 带上 **Cookie** 字段

# 第三章 HTTP 报文内的 HTTP 信息

## 3.1 HTTP 报文

HTTP 报文是由多行数据构成的字符串文本（用CRLF进行换行），分为**首部**和**主体**两部分，中间隔一空行（即两个CRLF回车换行符），**主体**不是必须的

* CRLF 即回车换行符，由回车符(0x0d)和换行符(0x0a)组成

## 3.2 报文首部结构

首部一般包含:
* **请求行**：包含用于请求的方法，请求 URI 和 HTTP 版本（请求专属）
* **状态行**：包含表明响应结果的状态码，原因短语和 HTTP 版本（响应专属）
* **首部字段**：包含表示请求和响应的各种条件和熟悉的各类首部，一般有4种：**通用首部、请求首部、响应首部、实体首部**
* **其它**：可能包含 HTTP 的 RFC 里未定义的首部，如 Cookie 等

## 3.3 编码提高传输速率

HTTP 可以在传输过程中通过编码压缩来提高传输速率，当然，会消耗更多 CPU 等资源。

### 报文主体与实体主体

* **报文(message)**：HTTP 通信中的基本单位，由 8 位组字节流组成
* **实体(entity)**：作为请求或响应的有效载荷数据（补充项）被传输，由实体首部和实体主体组成
  
HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体的内容产生变化，才导致它和报文主体产生差异。

### 压缩传输的内容编码

HTTP 中内容编码的功能可进行压缩操作，指明应用在实体内容上的编码格式，保持实体信息原样压缩，压缩后的实体由客户端接收并负责解码。
常用的内容编码：
* gzip (GNU zip)
* compress (UNIX 系统的标准压缩)
* deflate (zlib)
* identity (不进行编码)

### 分割发送的分块传输编码

在 HTTP 通信过程中，请求的资源未传输完成前，浏览器无法显示；在传输大容量数据是，把数据分割成多块，能让浏览器逐步显示页面，称为**分块传输编码**(Chunked Transfer Coding)。
分块传输编码将实体主体分为多块，每块用**十六进制**来标记大小，最后一块会使用 "0(CR+LF)" 来标记；接收客户端负责解码，恢复成编码前的实体主体。
HTTP/1.1 有**传输编码**(Transfer Coding)机制，可以在通信时按某种编码方式传输，但只作用于分块传输编码中


## 3.4 发送多种数据的多部分对象集合

MIME(Multipurpose Internet Mail Extensions 多用途因特网邮件扩展) 机制，允许邮件处理文本、图片、视频等不同类型数据，其中有一种 **多部分对象集合** 的方法来容纳多份不同类型的数据，在 HTTP 中也有用到：
* **multipart/form-data**：用于表单上传文件
  ```HTTP
    Content-Type: multipart/form-data; boundary=AaB03x

    --AaB03x
    Content-Disposition: form-data; name="field1"
    Joe Blow
    --AaB03x
    Content-Disposition: form-data; name="pics"; filename="file1.txt"
    Content-Type: text/plain
    ...（file1.txt的数据）...
    --AaB03x--
  ```
* **multipart、byteranges**：状态码 "206 Partial Content"(部分内容)，响应报文包含了多个范围的内容时使用
  ```HTTP
    HTTP/1.1 206 Partial Content
    Date: Fri, 13 Jul 2012 02:45:26 GMT
    Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT
    Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 500-999/8000
    ...（范围指定的数据）...
    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 7000-7999/8000
    ...（范围指定的数据）...
    --THIS_STRING_SEPARATES--
  ```

使用多部分对象集合时，需要在首部中加上 `Content-Type`；使用 boundary 字符串来划分各个实体，boundary 字符串前要有 "--"，集合结尾的 boundary 字符串末尾要有 "--"；每个实体中，都可以有首部字段，可以在某部分嵌套使用多部分对象集合

## 3.5 获取部分内容的范围请求

使用范围请求(Range Request)可以指定下载的实体范围，可用来断点续传；使用首部字段 Range 来指定资源的 byte 范围
* `Range:bytes=5001-10000`，5001-10000 字节
* `Range:bytes=5001-`，从 5001 字节之后的全部
* `Range:bytes=-3000,5000-7000`，从开头到 3000 字节和 5000-7000 字节

针对范围请求，响应会返回状态码为 `206 Partial Content` 以及 `Content-Type：multipart/byteranges` 的响应报文；如果服务器无法响应范围请求，则返回状态码 `200 OK` 和完整的实体内容

## 3.6 内容协商

客户端与服务器就响应的资源内容进行交涉，提供给客户端最合适的资源(比如根据浏览器的默认语言返回不同语言的页面)，以响应资源的语言、字符集、编码方式等作为判断的基准，使用以下首部字段：
`Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Language`

内容协商技术有 3 种类型：
* **服务器驱动协商**：以请求的首部字段为参考，服务器自动处理；但以浏览器发送的信息为依据，不一定能筛选出最优内容
* **客户端驱动协商**：用户从浏览器显示的可选列表中手动选择，或者用 JS 脚本自动选择，比如按 OS 或浏览器的类型，自行切换 PC 版和手机版的页面
* **透明协商**：以上两者结合


# 第四章 返回结果的 HTTP 状态码

* **1XX**：Inforamtional，信息性状态码，接收的请求正在处理
* **2XX**：Success，成功，请求正常处理完毕
* **3XX**：Redirection，重定向，需要进行附加操作以完成请求
* **4XX**：Client Error，客户端错误，服务器无法处理请求
* **5XX**：Server Error，服务器错误，服务器处理请求出错

## 4.2 2XX 成功

* **200 OK**：表示请求被正常处理了
* **204 No Content**：表示请求被正常处理，但响应报文中不含实体主体，也不允许返回实体主体；此时，浏览器的页面不会更新。一般在只需要客户端往服务器发送信息，而服务器不需要返回信息时使用
* **206 Partial Content**：范围请求被正常处理，响应报文中包含由 `Content-Range` 指定范围的实体内容

## 4.3 3XX 重定向

* **301 Moved Permanently**：永久性重定向，表示请求的资源已被分配了新的 URI，以后应使用 `Location` 首部字段提示的 URI 访问。会更新书签 ？
* **302 Found**：临时性重定向，表示本次应该用新的 URI 访问资源。不会更新书签 ？
* **303 See Other**：表示请求的资源存在另一个 URI，应使用 GET 方法获取。和 302 的区别在于，需要以 GET 方法请求新的 URI
  * 当 301、302、303 状态码返回时，几乎所有浏览器都会把 POST 改为 GET，并删除请求报文内的主体，之后自动再次发送请求。301、302 标准是禁止将 POST 改为 GET 的，但实际使用时大家都这么做 ？
* **304 Not Modified**：表示客户端发送附带条件的请求时，服务器允许访问资源，但未满足条件。此时，不包含任何响应主体部分；304 其实和重定向没什么关系
  * 附带条件的请求是指 GET 请求包含 `If-Match, If-Modified-Since, If-None-Match, If-Range, If-Unmodified-Since` 中任一首部
* **307 Temporary Redirect**：临时重定向，与 302 相同，但严格遵照标准，不会从 POST 变为 GET

## 4.4 4XX 客户端错误

* **400 Bad Request**：表示请求报文有语法错误，需要修改请求内容再次发送；浏览器会像 `200 OK` 一样对待该状态码 ？
* **401 Unauthorized**：表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息，如果之前已有一次请求，则表示用户认证失败
* **403 Forbidden**：表示拒绝访问该资源，不需要给出拒绝理由
* **404 Not Found**：表示无法找到该资源

## 4.5 5XX 服务器错误

* **500 Internal Server Error**：表示服务器在执行请求是发生了错误
* **503 Service Unavailable**：表示服务器暂时处于超负载或停机维护，无法处理请求；若事先得知恢复需要的时间，最好写入 `RetryAfter` 首部字段再返回