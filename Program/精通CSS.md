# 第二章 为样式找到应用目标

## 2.1 常用的选择器

`tagName` 标签选择器， `.class` 类选择器，`#id` id选择器， `parent child` 后代选择器

### 伪类

* `:link :visited` 称为**链接伪类**，只能用于锚元素。
* `:hover :active :focus` 称为**动态伪类**，理论上可用于任何元素。

## 2.3 高级选择器

`parent>child` 子选择器，`h2+p` 其后相邻同胞选择器（IE7以上都支持，但在IE7中，父子元素之间有HTML注释会出问题）
* 在不兼容的浏览器中，可以使用以下方法实现相同效果
    ```CSS
    /*先将样式应用到所有后代元素，再将非直接子元素的样式还原*/
    #nav li { /*想实现在子元素上的效果*/ }
    #nav li * { /*还原非直接子元素的样式*/ }
    ```

`[attr="value"]`属性选择器
* 属性选择器的几种形态：
    * `[attribute]`：根据属性名选择
    * `[attribute='value']`：根据属性值选择
    * `[attribute~='value']`：根据属性值之一选择
    * `[attribute|='value']`：选择属性值以value开头的属性的元素（value或value-*）

### 层叠和特殊性（优先级）

层叠采用以下重要度次序：
* 标有 `!important` 的用户样式
* 标有 `!important` 的作者样式
* 作者样式
* 用户样式
* 浏览器/用户代理应用的样式

然后根据选择器的特殊性来决定优先度，优先度相同的以后定义的规则优先。
特殊性分为4个等级：a、b、c、d
* **行内样式：** a = 1（1000）
* **id选择器：** b = 数量（X * 100）
* **类、伪类、属性选择器：** c = 数量（X * 10）
* **类型（标签）、伪元素选择器：** d = 数量（X * 1）

**Tip：** 在body标签上添加id或类，使用特殊性来灵活控制站点的设计与布局

### 继承

后代元素会继承其父元素的某些属性，比如字体、颜色，且继承的样式的特殊性为空，直接应用于元素的样式会覆盖继承的样式。

## 2.4 规划、组织和维护样式表

### 对文档应用样式

对HTML应用CSS有几种方法（其中的`type`属性都是可省略的）：
1. 使用`style`标签，在其中直接书写CSS样式
    ```HTML
    <style type="text/css">
        ...
    </style>
    ```
2. 外部CSS文件，使用`link`标签导入
    ```HTML
    <link href="/css/basic.css" rel="stylesheet" type="text/css" />
    ```
3. 在CSS代码（`style`标签中或CSS文件中）中使用`@import`导入外部CSS文件
    ```HTML
    <style type="text/css">
        @import url("/css/basic.css");  /*双引号加不加无所谓*/
    </style>
    ```
`import`要比`link`慢

把CSS文件分成多个会影响速度，且浏览器从同一域能下载的文件数量有限，老式浏览器通常是2个，现代浏览器8个（查了资料，这里应该指的是浏览器**最大并发请求资源数**，即同一域名下同一时间能请求的资源数量）。推荐使用单一CSS文件，还便于维护。

### 代码结构
通常把最一般的样式放在最前面，越特殊的放在越后面，比如以下结构：
* 一般性样式
    * body样式
    * reset样式（重写标签的默认样式，可以统一不同浏览器间的标签样式）
    * a、h及其它标签的样式
* 辅助样式
    * 表单
    * 通知和错误
    * 一致的条目
* 页面结构
    * 标题、页脚和导航
    * 布局
    * 其它页面结构元素
* 页面组件
    * 各个页面
* 覆盖

可以使用统一风格的注释块来分割各个部分。

### 自我提示
在注释中，用某些关键字来标注，比如`@todo:`、`@bugfix:`、`@workaoround:`（并不完善的权宜之计）等，可以参考CSSDoc项目（http://cssdoc.net），这个项目的目的是为样式表开发一套标准的注释语法。

不过注释太多也会增加CSS文件的体积，可以采用服务器端压缩的方式，删除注释和空格，打包成GZIP格式，所有现代浏览器都可以处理用GZIP压缩的文件并即时解压。

# 第三章 可视化格式模型

## 3.1 盒模型概述

盒模型结构：`content - padding - border - margin - outline(不占用空间)`
盒模型的 `width` 和 `height` 指的是 `content` 的宽和高，可以通过 `box-sizing: border-box`（默认值是 `content-box`）将其设为 `content + padding + border` 的大小。
在IE的早期版本，包括IE6中，使用的就是`border-box`的盒模型。

### 外边距叠加

外边距叠加是指：在**垂直**方向上，两个或多个 `margin` 相邻时，会产生叠加，只留下最高的 `margin`。
具体情况包括：
* 两元素相叠，第一个元素的 `margin-bottom` 与第二个元素的 `margin-top` 叠加
* 一个元素包含另一个元素，如果没有 `padding` 或 `border` 将 `margin` 分隔开，它们的 `margin-top/bottom` 也会叠加
* 一个元素本身的 `margin-top/bottom`，若没有 `content, padding, border` 的分隔，也会叠加

只有**标准文档流**中的**块框**才会发生外边距叠加。**行内框、浮动框或绝对定位框**则不会。

## 3.2 定位概述

### 可视化格式模型

HTML元素主要分为**块级元素**和**行级元素**，可以用 `display` 属性来改变。CSS中有3种基本定位机制：**标准文档流、浮动和绝对定位**。除非专门指定，否则所有框都位于**标准文档流**中：**块级框**垂直排列；**行内框**在一行中水平排列，且只能调整**水平方向**的 `margin, padding, border`，垂直方向的无效，**高度、宽度**也无效，只可以通过 `line-height` 来调节一行的**行高**。`display: inline-block` 可以使元素在行内排列同时还可以像块级元素一样设置宽高以及垂直方向边距。

**匿名块、行框：** 在块元素开头的裸露文本，会自动被当成一个块元素对待，称为**匿名块框**(**!这说法存疑，经测试，并没有发现块级元素开头的文本表现出块框的特性**)。块级元素内的文本行则会被当成**匿名行框**，如包含3行文本的段落，每行文本形成一个匿名行框。匿名框一般来说无法直接应用样式，除非用 `:first-line` 伪元素。可知，**屏幕上看到的所有东西都形成某种框**

### 相对定位 (relative)

相对定位元素相对于其原本的位置进行偏移，不过它实际占用的空间仍是它原本的位置（仍是标准文档流的一部分），所以相对定位元素看起来会覆盖其它框

### 绝对定位 (absolute)

绝对定位元素与标准文档流无关，因此不占据空间，其位置是相对于**最近的已定位祖先元素**来确定的，如果没有已定位的祖先元素，则相对于**初始包含块**来确定。

### 固定定位 (fixed)

**固定定位**是**绝对定位**的一种，差异是**固定定位**的包含块是 `viewport`，所以固定定位元素总会出现在窗口的相同位置。（IE6及以下不支持固定定位，IE7部分支持，但有许多bug！）

### 浮动 (float)

浮动框向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边缘(经测试，只有左右，上边缘会被在其之前的**块级元素**挡住)，浮动框同样不属于标准文档流。浮动框就像在水中的浮体一样，拼命向上，容器的宽度不够时就浮在第二行，浮块大小不一还会被卡住。。。

#### 行框和clear

**浮动框**虽然说不会影响其他框，但实际上，它会挤掉**行内框**，展现出文字围绕**浮动框**排列的效果。
**清除浮动：** 使用`clear：left/right/both`，对应左/右/两种浮动，应用了该属性的**块级元素**，将会消除其之前的浮动元素对其本身及其后元素的影响（或者说 消除其本身及其后元素的浮动，除非对它们应用`float`?）；清除浮动还能使浮动元素的父容器能感知到浮动元素的大小，从而适应其大小（另一种方法是为父容器也添加浮动）。此外，设置了 `overflow：hidden/auto` 的元素，将清除其包含的所有元素的浮动，或者使用 `:after` 伪元素来添加 `clear`

# 第四章 背景图像效果
